{
  "title": "الإعدادات كاملة",
  "document": {
    "1_root_configs": {
      "title": "إعدادات الجذر Root Configs",
      "eslint_config_js": "import js from \"@eslint/js\";\nimport tseslint from \"typescript-eslint\";\nimport boundaries from \"eslint-plugin-boundaries\";\nimport globals from \"globals\";\n\n/**\n * Flat ESLint config (ESLint v9+)\n * يفرض Boundaries على monorepo (apps/ vs packages/)\n * ويمنع الاختراقات المعمارية التي تفسد (7.5 Boundaries-Aware Merging)\n */\nexport default [\n  js.configs.recommended,\n\n  ...tseslint.config({\n    files: [\"**/*.{ts,tsx,mts,cts}\"],\n    extends: [\n      ...tseslint.configs.recommendedTypeChecked,\n      ...tseslint.configs.stylisticTypeChecked,\n    ],\n    languageOptions: {\n      parserOptions: {\n        // Project Service أفضل من project: [] في أغلب monorepos\n        projectService: true,\n        tsconfigRootDir: import.meta.dirname,\n      },\n      globals: {\n        ...globals.node,\n        ...globals.browser,\n      },\n    },\n    plugins: {\n      boundaries,\n    },\n    settings: {\n      // تعريف عناصر الحدود المعمارية (Simple Boundaries)\n      \"boundaries/include\": [\"apps/**\", \"packages/**\"],\n      \"boundaries/elements\": [\n        { type: \"app\", pattern: \"apps/*\" },\n\n        { type: \"pkg-shared\", pattern: \"packages/shared\" },\n        { type: \"pkg-schemas\", pattern: \"packages/schemas\" },\n        { type: \"pkg-storage\", pattern: \"packages/storage\" },\n        { type: \"pkg-tooling\", pattern: \"packages/tooling\" },\n\n        { type: \"pkg-analysis\", pattern: \"packages/analysis\" },\n        { type: \"pkg-harness\", pattern: \"packages/harness\" },\n\n        { type: \"pkg-planning\", pattern: \"packages/planning\" },\n        { type: \"pkg-refactor\", pattern: \"packages/refactor\" },\n\n        { type: \"pkg-llm\", pattern: \"packages/llm\" },\n        { type: \"pkg-engine\", pattern: \"packages/engine\" },\n      ],\n    },\n    rules: {\n      // ---------- قواعد عامة ----------\n      \"no-console\": \"off\",\n      \"@typescript-eslint/no-unused-vars\": [\"error\", { argsIgnorePattern: \"^_\" }],\n      \"@typescript-eslint/consistent-type-imports\": [\n        \"error\",\n        { prefer: \"type-imports\", fixStyle: \"separate-type-imports\" },\n      ],\n\n      // ---------- قواعد Boundaries (الخيار الثالث: Simple Boundaries) ----------\n      \"boundaries/no-unknown-files\": \"error\",\n\n      /**\n       * قاعدة الحوكمة:\n       * - apps يمكنها استيراد أي packages\n       * - packages منخفضة المستوى (schemas/shared/storage) لا تستورد من المستوى الأعلى\n       * - tooling لا يعتمد على analysis/planning/refactor/engine/llm/harness\n       * - analysis لا يعتمد على planning/refactor/engine\n       * - planning لا يعتمد على refactor/engine\n       * - refactor لا يعتمد على analysis/planning/engine\n       * - llm لا يعتمد على engine\n       */\n      \"boundaries/element-types\": [\n        \"error\",\n        {\n          default: \"disallow\",\n          rules: [\n            // apps: مسموح لها استيراد كل packages\n            {\n              from: \"app\",\n              allow: [\n                \"app\",\n                \"pkg-shared\",\n                \"pkg-schemas\",\n                \"pkg-storage\",\n                \"pkg-tooling\",\n                \"pkg-analysis\",\n                \"pkg-harness\",\n                \"pkg-planning\",\n                \"pkg-refactor\",\n                \"pkg-llm\",\n                \"pkg-engine\",\n              ],\n            },\n\n            // Base leaf-ish\n            { from: \"pkg-schemas\", allow: [\"pkg-schemas\"] },\n            { from: \"pkg-shared\", allow: [\"pkg-shared\", \"pkg-schemas\"] },\n            {\n              from: \"pkg-storage\",\n              allow: [\"pkg-storage\", \"pkg-schemas\", \"pkg-shared\"],\n            },\n\n            // tooling يعتمد فقط على base\n            {\n              from: \"pkg-tooling\",\n              allow: [\"pkg-tooling\", \"pkg-schemas\", \"pkg-shared\", \"pkg-storage\"],\n            },\n\n            // analysis يعتمد على base + tooling فقط\n            {\n              from: \"pkg-analysis\",\n              allow: [\n                \"pkg-analysis\",\n                \"pkg-schemas\",\n                \"pkg-shared\",\n                \"pkg-storage\",\n                \"pkg-tooling\",\n              ],\n            },\n\n            // harness يعتمد على base + tooling + analysis (لربط العقود/الإشارات)\n            {\n              from: \"pkg-harness\",\n              allow: [\n                \"pkg-harness\",\n                \"pkg-schemas\",\n                \"pkg-shared\",\n                \"pkg-storage\",\n                \"pkg-tooling\",\n                \"pkg-analysis\",\n              ],\n            },\n\n            // planning يعتمد على base + analysis + harness + tooling\n            {\n              from: \"pkg-planning\",\n              allow: [\n                \"pkg-planning\",\n                \"pkg-schemas\",\n                \"pkg-shared\",\n                \"pkg-storage\",\n                \"pkg-tooling\",\n                \"pkg-analysis\",\n                \"pkg-harness\",\n                \"pkg-llm\",\n              ],\n            },\n\n            // refactor يعتمد على base + tooling + llm (للـ Patch Author) + storage\n            {\n              from: \"pkg-refactor\",\n              allow: [\n                \"pkg-refactor\",\n                \"pkg-schemas\",\n                \"pkg-shared\",\n                \"pkg-storage\",\n                \"pkg-tooling\",\n                \"pkg-llm\",\n              ],\n            },\n\n            // llm يعتمد على schemas/shared فقط\n            {\n              from: \"pkg-llm\",\n              allow: [\"pkg-llm\", \"pkg-schemas\", \"pkg-shared\"],\n            },\n\n            // engine: المستوى الأعلى الذي ينسق الجميع\n            {\n              from: \"pkg-engine\",\n              allow: [\n                \"pkg-engine\",\n                \"pkg-schemas\",\n                \"pkg-shared\",\n                \"pkg-storage\",\n                \"pkg-tooling\",\n                \"pkg-analysis\",\n                \"pkg-harness\",\n                \"pkg-planning\",\n                \"pkg-refactor\",\n                \"pkg-llm\",\n              ],\n            },\n          ],\n        },\n      ],\n    },\n  }),\n\n  // تجاهل artifacts والـ dist\n  {\n    ignores: [\"**/node_modules/**\", \"**/dist/**\", \"**/build/**\", \"artifacts/**\"],\n  },\n];",
      "prettier_config_cjs": "/** @type {import(\"prettier\").Config} */\nmodule.exports = {\n  semi: true,\n  singleQuote: false,\n  trailingComma: \"all\",\n  printWidth: 100,\n  tabWidth: 2,\n};",
      "tsconfig_base_json": {
        "compilerOptions": {
          "target": "ES2022",
          "module": "NodeNext",
          "moduleResolution": "NodeNext",
          "lib": [
            "ES2022",
            "DOM"
          ],
          "strict": true,
          "noUncheckedIndexedAccess": true,
          "exactOptionalPropertyTypes": true,
          "skipLibCheck": true,
          "resolveJsonModule": true,
          "esModuleInterop": true,
          "types": [
            "node"
          ]
        }
      },
      "tsconfig_node_json": {
        "extends": "./tsconfig.base.json",
        "compilerOptions": {
          "lib": [
            "ES2022"
          ],
          "types": [
            "node"
          ]
        }
      }
    },
    "2_depcruise_config": {
      "title": "إعداد depcruise (Dependency Cruiser) كامل",
      "dependency_cruiser_js": "/** @type {import('dependency-cruiser').IConfiguration} */\nmodule.exports = {\n  forbidden: [\n    // منع الدوائر في كل المشروع\n    {\n      name: \"no-circular\",\n      severity: \"error\",\n      from: {},\n      to: { circular: true }\n    },\n\n    // apps لا يُستورد داخل packages\n    {\n      name: \"no-packages-import-apps\",\n      severity: \"error\",\n      from: { path: \"^packages/\" },\n      to: { path: \"^apps/\" }\n    },\n\n    // schemas يجب أن تكون leaf\n    {\n      name: \"schemas-should-be-leaf\",\n      severity: \"error\",\n      from: { path: \"^packages/schemas/\" },\n      to: { path: \"^packages/(analysis|planning|refactor|engine|llm|harness|tooling|storage|shared)/\" }\n    },\n\n    // shared منخفض المستوى\n    {\n      name: \"shared-should-not-depend-on-high-level\",\n      severity: \"error\",\n      from: { path: \"^packages/shared/\" },\n      to: { path: \"^packages/(analysis|planning|refactor|engine|llm|harness)/\" }\n    },\n\n    // storage منخفض المستوى\n    {\n      name: \"storage-should-not-depend-on-high-level\",\n      severity: \"error\",\n      from: { path: \"^packages/storage/\" },\n      to: { path: \"^packages/(analysis|planning|refactor|engine|llm|harness)/\" }\n    },\n\n    // tooling يعتمد فقط على base\n    {\n      name: \"tooling-depends-only-on-base\",\n      severity: \"error\",\n      from: { path: \"^packages/tooling/\" },\n      to: { path: \"^packages/(analysis|planning|refactor|engine|llm|harness)/\" }\n    },\n\n    // analysis لا يعتمد على planning/refactor/engine\n    {\n      name: \"analysis-should-not-depend-on-planning-refactor-engine\",\n      severity: \"error\",\n      from: { path: \"^packages/analysis/\" },\n      to: { path: \"^packages/(planning|refactor|engine)/\" }\n    },\n\n    // planning لا يعتمد على refactor/engine\n    {\n      name: \"planning-should-not-depend-on-refactor-engine\",\n      severity: \"error\",\n      from: { path: \"^packages/planning/\" },\n      to: { path: \"^packages/(refactor|engine)/\" }\n    },\n\n    // refactor لا يعتمد على analysis/planning/engine\n    {\n      name: \"refactor-should-not-depend-on-analysis-planning-engine\",\n      severity: \"error\",\n      from: { path: \"^packages/refactor/\" },\n      to: { path: \"^packages/(analysis|planning|engine)/\" }\n    },\n\n    // llm لا يعتمد على engine\n    {\n      name: \"llm-should-not-depend-on-engine\",\n      severity: \"error\",\n      from: { path: \"^packages/llm/\" },\n      to: { path: \"^packages/engine/\" }\n    }\n  ],\n\n  options: {\n    doNotFollow: {\n      path: \"node_modules|dist|build|out|artifacts\"\n    },\n    enhancedResolveOptions: {\n      exportsFields: [\"exports\"],\n      conditionNames: [\"import\", \"require\", \"node\"]\n    },\n    tsConfig: {\n      fileName: \"tsconfig.base.json\"\n    }\n  }\n};",
      "packages_tooling_package_json": {
        "name": "@pkg/tooling",
        "private": true,
        "type": "module",
        "main": "dist/index.js",
        "types": "dist/index.d.ts",
        "scripts": {
          "build": "tsc -p tsconfig.json",
          "typecheck": "tsc -p tsconfig.json --noEmit",
          "lint": "eslint .",
          "deps:check": "depcruise -c ../../dependency-cruiser.js ../../"
        },
        "dependencies": {
          "@pkg/shared": "workspace:*",
          "@pkg/schemas": "workspace:*"
        },
        "devDependencies": {
          "dependency-cruiser": "^16.0.0",
          "typescript": "^5.5.0"
        }
      },
      "packages_tooling_tsconfig_json": {
        "extends": "../../tsconfig.node.json",
        "compilerOptions": {
          "rootDir": "src",
          "outDir": "dist",
          "composite": true,
          "declaration": true,
          "declarationMap": true
        },
        "include": [
          "src/**/*.ts"
        ]
      }
    },
    "3_in_repo_harness_templates": {
      "title": "قوالب .refactor-harness التي تُكتب داخل repo الهدف (In-Repo Harness Templates)",
      "target_repo_refactor_harness_vitest_config_ts": "import { defineConfig } from \"vitest/config\";\nimport path from \"node:path\";\n\nexport default defineConfig({\n  test: {\n    environment: \"node\",\n    globals: false,\n    include: [\".refactor-harness/tests/**/*.test.ts\"],\n    exclude: [\"**/node_modules/**\", \"**/dist/**\", \"**/build/**\"],\n    // لتفادي تضارب alias الخاصة بالمشروع الهدف:\n    alias: {\n      \"@harness\": path.resolve(process.cwd(), \".refactor-harness/src\"),\n    },\n  },\n});",
      "target_repo_refactor_harness_tsconfig_json": {
        "extends": "../tsconfig.json",
        "compilerOptions": {
          "types": [
            "vitest/globals",
            "node"
          ],
          "noEmit": true
        },
        "include": [
          ".refactor-harness/**/*.ts",
          ".refactor-harness/**/*.test.ts"
        ]
      },
      "target_repo_refactor_harness_harness_config_ts": "export type HarnessCase =\n  | {\n      id: string;\n      kind: \"moduleExportCall\";\n      modulePath: string; // مسار داخل repo الهدف (relative)\n      exportName: string; // اسم export\n      inputs: unknown[];  // مصفوفة مدخلات تُستخدم كـ args (call)\n    }\n  | {\n      id: string;\n      kind: \"moduleDefaultCall\";\n      modulePath: string;\n      inputs: unknown[];\n    };\n\nexport interface HarnessConfig {\n  // baseline fixtures تُكتب هنا بواسطة الأداة:\n  baselineDir: string; // \".refactor-harness/fixtures/baseline\"\n  // الحالات تُملأ تلقائيًا بواسطة Harness Agent:\n  cases: HarnessCase[];\n}\n\n/**\n * سيقوم Harness Agent بملء cases تلقائيًا بناءً على:\n * - العقود (7.4)\n * - المخاطر (7.3)\n * - نقاط الدخول (النواقص: entrypoints)\n */\nexport const harnessConfig: HarnessConfig = {\n  baselineDir: \".refactor-harness/fixtures/baseline\",\n  cases: [\n    // مثال:\n    // {\n    //   id: \"parse-email-v1\",\n    //   kind: \"moduleExportCall\",\n    //   modulePath: \"src/lib/parseEmail.ts\",\n    //   exportName: \"parseEmail\",\n    //   inputs: [\"TEST@EXAMPLE.COM\"]\n    // }\n  ],\n};",
      "target_repo_refactor_harness_src_run_case_ts": "import path from \"node:path\";\nimport { pathToFileURL } from \"node:url\";\nimport type { HarnessCase } from \"../harness.config\";\n\nexport async function runCase(c: HarnessCase): Promise<unknown> {\n  const abs = path.resolve(process.cwd(), c.modulePath);\n  const mod = await import(pathToFileURL(abs).href);\n\n  if (c.kind === \"moduleExportCall\") {\n    const fn = mod?.[c.exportName];\n    if (typeof fn !== \"function\") {\n      throw new Error(\n        `Harness: export \"${c.exportName}\" not found or not a function in ${c.modulePath}`,\n      );\n    }\n    return await fn(...c.inputs);\n  }\n\n  if (c.kind === \"moduleDefaultCall\") {\n    const fn = mod?.default;\n    if (typeof fn !== \"function\") {\n      throw new Error(`Harness: default export not a function in ${c.modulePath}`);\n    }\n    return await fn(...c.inputs);\n  }\n\n  const _exhaustive: never = c;\n  return _exhaustive;\n}",
      "target_repo_refactor_harness_src_fixtures_ts": "import fs from \"node:fs\";\nimport path from \"node:path\";\n\nexport function readJson(absPath: string): unknown {\n  const raw = fs.readFileSync(absPath, \"utf8\");\n  return JSON.parse(raw);\n}\n\nexport function writeJson(absPath: string, value: unknown): void {\n  fs.mkdirSync(path.dirname(absPath), { recursive: true });\n  fs.writeFileSync(absPath, JSON.stringify(value, null, 2), \"utf8\");\n}\n\nexport function baselinePath(baselineDir: string, caseId: string): string {\n  return path.resolve(process.cwd(), baselineDir, `${caseId}.json`);\n}",
      "target_repo_refactor_harness_tests_equivalence_test_ts": "import fs from \"node:fs\";\nimport { describe, it, expect } from \"vitest\";\nimport { harnessConfig } from \"../harness.config\";\nimport { runCase } from \"@harness/run-case\";\nimport { baselinePath, readJson } from \"@harness/fixtures\";\n\n/**\n * هذا الاختبار يفشل إذا تغيّر السلوك مقارنةً بالـ baseline\n * baseline files يتم إنشاؤها بواسطة الأداة قبل الريفكتور (باتش baseline).\n */\ndescribe(\"Refactor Equivalence Harness\", () => {\n  it(\"all cases match baseline\", async () => {\n    for (const c of harnessConfig.cases) {\n      const expectedPath = baselinePath(harnessConfig.baselineDir, c.id);\n\n      if (!fs.existsSync(expectedPath)) {\n        throw new Error(\n          `Missing baseline fixture for case \"${c.id}\". Expected: ${expectedPath}`,\n        );\n      }\n\n      const expected = readJson(expectedPath);\n      const actual = await runCase(c);\n\n      // مقارنة مباشرة (يمكن لاحقًا إدخال normalization حسب العقود)\n      expect(actual).toEqual(expected);\n    }\n  });\n});",
      "target_repo_refactor_harness_README_md": "# .refactor-harness\n\nهذا مجلد يُدار آليًا بواسطة أداة repo-refactor-ai.\n\n## ما هو؟\nحزام أمان سلوكي (Behavioral Equivalence Harness) يضمن أن الريفكتور لا يغيّر المخرجات مقارنةً بـ baseline.\n\n## كيف يعمل؟\n- الأداة تكتب baseline fixtures في:\n  .refactor-harness/fixtures/baseline/*.json\n- ثم تشغل:\n  vitest -c .refactor-harness/vitest.config.ts\n\n## ملاحظات\n- لا تعدّل الملفات يدويًا إلا إذا كنت تريد تغيير سياسة المقارنة (غير موصى به أثناء التشغيل الآلي).\n- الحالات (cases) تُولّد تلقائيًا حسب المخاطر والعقود."
    },
    "4_schemas_package": {
      "title": "packages/schemas — ملفات Zod Schemas كاملة (Evidence/Findings/Plan/Report/Telemetry)",
      "packages_schemas_package_json": {
        "name": "@pkg/schemas",
        "private": true,
        "type": "module",
        "main": "dist/index.js",
        "types": "dist/index.d.ts",
        "scripts": {
          "build": "tsc -p tsconfig.json",
          "typecheck": "tsc -p tsconfig.json --noEmit",
          "lint": "eslint ."
        },
        "dependencies": {
          "zod": "^3.23.8"
        },
        "devDependencies": {
          "typescript": "^5.5.0"
        }
      },
      "packages_schemas_tsconfig_json": {
        "extends": "../../tsconfig.node.json",
        "compilerOptions": {
          "rootDir": "src",
          "outDir": "dist",
          "composite": true,
          "declaration": true,
          "declarationMap": true
        },
        "include": [
          "src/**/*.ts"
        ]
      },
      "packages_schemas_src_evidence_ts": "import { z } from \"zod\";\n\nexport const CandidateKindSchema = z.enum([\"dead_code\", \"merge\", \"dedupe\", \"move\", \"rename\", \"extract\"]);\nexport type CandidateKind = z.infer<typeof CandidateKindSchema>;\n\nexport const RiskBandSchema = z.enum([\"low\", \"medium\", \"high\", \"blocked\"]);\nexport type RiskBand = z.infer<typeof RiskBandSchema>;\n\nexport const ToolHitsSchema = z.object({\n  knip: z.string().nullable().optional(),\n  depcheck: z.string().nullable().optional(),\n  jscpd: z\n    .object({\n      clusterId: z.string(),\n      similarity: z.number().min(0).max(1),\n    })\n    .nullable()\n    .optional(),\n  depcruise: z.string().nullable().optional(),\n});\n\nexport const ImportGraphEvidenceSchema = z.object({\n  inboundCount: z.number().int().min(0),\n  inboundFiles: z.array(z.string()),\n});\n\nexport const CallGraphEvidenceSchema = z.object({\n  callers: z.array(z.string()),\n});\n\nexport const TSReferencesEvidenceSchema = z.object({\n  refCount: z.number().int().min(0),\n  refs: z.array(\n    z.object({\n      file: z.string(),\n      line: z.number().int().min(1),\n      col: z.number().int().min(1),\n      kind: z.string(),\n    }),\n  ),\n});\n\nexport const EvidenceTargetSchema = z.object({\n  file: z.string(),\n  symbol: z.string().nullable().optional(),\n  range: z.tuple([z.number().int().min(0), z.number().int().min(0)]).optional(),\n});\n\nexport const EvidenceExceptionsSchema = z.object({\n  dynamicImportSuspicion: z.boolean(),\n  sideEffectModule: z.boolean(),\n  publicApiExposure: z.boolean(),\n});\n\nexport const RiskSchema = z.object({\n  score: z.number().int().min(0).max(1000),\n  band: RiskBandSchema,\n  reasons: z.array(z.string()),\n});\n\nexport const EvidencePacketSchema = z.object({\n  id: z.string(),\n  kind: CandidateKindSchema,\n  target: EvidenceTargetSchema,\n  evidence: z.object({\n    importGraph: ImportGraphEvidenceSchema.optional(),\n    callGraph: CallGraphEvidenceSchema.optional(),\n    tsReferences: TSReferencesEvidenceSchema.optional(),\n    toolHits: ToolHitsSchema.optional(),\n  }),\n  exceptions: EvidenceExceptionsSchema,\n  risk: RiskSchema,\n  recommendedAction: z.enum([\"delete\", \"extract\", \"merge\", \"unify\", \"move\", \"rename\", \"keep\", \"propose_only\"]),\n  requiresHarness: z.boolean(),\n});\nexport type EvidencePacket = z.infer<typeof EvidencePacketSchema>;\n\nexport const EvidencePackSchema = z.object({\n  repoId: z.string(),\n  runId: z.string(),\n  generatedAt: z.string(),\n  packets: z.array(EvidencePacketSchema),\n});\nexport type EvidencePack = z.infer<typeof EvidencePackSchema>;",
      "packages_schemas_src_findings_ts": "import { z } from \"zod\";\nimport { EvidencePacketSchema } from \"./evidence\";\n\nexport const DeadCodeCandidateSchema = z.object({\n  evidenceId: z.string(),\n  reason: z.string(),\n});\nexport type DeadCodeCandidate = z.infer<typeof DeadCodeCandidateSchema>;\n\nexport const TextCloneOccurrenceSchema = z.object({\n  file: z.string(),\n  startLine: z.number().int().min(1),\n  endLine: z.number().int().min(1),\n});\n\nexport const CloneClusterSchema = z.object({\n  clusterId: z.string(),\n  similarity: z.number().min(0).max(1),\n  occurrences: z.array(TextCloneOccurrenceSchema).min(2),\n});\nexport type CloneCluster = z.infer<typeof CloneClusterSchema>;\n\n/**\n * 7.1 Semantic Clone Clustering\n */\nexport const SemanticCloneNodeSchema = z.object({\n  file: z.string(),\n  symbol: z.string().nullable().optional(),\n  astHash: z.string(),\n  startLine: z.number().int().min(1).optional(),\n  endLine: z.number().int().min(1).optional(),\n});\nexport const SemanticCloneClusterSchema = z.object({\n  clusterId: z.string(),\n  confidence: z.number().min(0).max(1),\n  nodes: z.array(SemanticCloneNodeSchema).min(2),\n  suggestedRefactor: z.enum([\"extract_function\", \"extract_module\", \"strategy\", \"template_method\", \"unify_util\"]),\n});\nexport type SemanticCloneCluster = z.infer<typeof SemanticCloneClusterSchema>;\n\nexport const DuplicateFunctionSchema = z.object({\n  evidenceId: z.string(),\n  signature: z.string(),\n  candidates: z.array(\n    z.object({\n      file: z.string(),\n      symbol: z.string(),\n      score: z.number().min(0).max(1),\n    }),\n  ),\n  suggestedUnification: z.enum([\"rename_and_reuse\", \"extract_common_core\", \"replace_with_shared_util\"]),\n});\nexport type DuplicateFunction = z.infer<typeof DuplicateFunctionSchema>;\n\nexport const MergeCandidateSchema = z.object({\n  evidenceId: z.string(),\n  kind: z.enum([\"merge_files\", \"merge_modules\", \"extract_shared\", \"split_module\"]),\n  rationale: z.string(),\n  targets: z.array(z.string()).min(1),\n  notes: z.array(z.string()).optional(),\n});\nexport type MergeCandidate = z.infer<typeof MergeCandidateSchema>;\n\nexport const BoundaryViolationSchema = z.object({\n  fromFile: z.string(),\n  toFile: z.string(),\n  rule: z.string(),\n});\nexport type BoundaryViolation = z.infer<typeof BoundaryViolationSchema>;\n\nexport const FindingsSchema = z.object({\n  runId: z.string(),\n  repoId: z.string(),\n  evidencePackets: z.array(EvidencePacketSchema),\n\n  deadCode: z.array(DeadCodeCandidateSchema),\n  textClones: z.array(CloneClusterSchema),\n  semanticClones: z.array(SemanticCloneClusterSchema),\n  duplicateFunctions: z.array(DuplicateFunctionSchema),\n  mergeCandidates: z.array(MergeCandidateSchema),\n  boundaryViolations: z.array(BoundaryViolationSchema),\n\n  notes: z.array(z.string()).optional(),\n});\nexport type Findings = z.infer<typeof FindingsSchema>;",
      "packages_schemas_src_plan_ts": "import { z } from \"zod\";\nimport { RiskBandSchema } from \"./evidence\";\n\nexport const ApprovalStatusSchema = z.enum([\"PENDING\", \"APPROVED\", \"REJECTED\"]);\nexport type ApprovalStatus = z.infer<typeof ApprovalStatusSchema>;\n\nexport const PlanActionSchema = z.enum([\n  \"delete_dead\",\n  \"unify_duplicates\",\n  \"extract_function\",\n  \"extract_module\",\n  \"merge_files\",\n  \"move_file\",\n  \"rename_symbol\",\n  \"update_imports\",\n  \"add_harness\",\n  \"generate_baseline\",\n  \"cleanup_harness\",\n  \"format_fix\",\n]);\n\nexport const PlanStepSchema = z.object({\n  stepId: z.string(),\n  patchTitle: z.string(),\n  actions: z.array(PlanActionSchema).min(1),\n  targets: z.array(z.string()).min(1),\n  evidenceRefs: z.array(z.string()).min(1),\n  riskBand: RiskBandSchema,\n  requiresHarness: z.boolean(),\n  preChecks: z.array(z.string()).default([]),\n  postChecks: z.array(z.string()).default([]),\n  rollbackStrategy: z.enum([\"git_revert_commit\", \"git_reset_hard\"]).default(\"git_revert_commit\"),\n});\nexport type PlanStep = z.infer<typeof PlanStepSchema>;\n\nexport const RefactorPlanSchema = z.object({\n  planId: z.string(),\n  repoId: z.string(),\n  runId: z.string(),\n  generatedAt: z.string(),\n\n  approvalStatus: ApprovalStatusSchema.default(\"PENDING\"),\n  steps: z.array(PlanStepSchema).min(1),\n\n  // سياسات تشغيلية\n  policies: z.object({\n    evidenceRequired: z.literal(true),\n    atomicCommits: z.literal(true),\n    stopOnScopeExplosion: z.literal(true),\n    harnessInRepo: z.literal(true),\n    testRunner: z.literal(\"vitest\"),\n  }),\n\n  // حدود الانفجار\n  scopeLimits: z.object({\n    maxChangedFilesPerStep: z.number().int().min(1).default(50),\n    maxChangedLinesPerStep: z.number().int().min(1).default(2000),\n  }),\n});\nexport type RefactorPlan = z.infer<typeof RefactorPlanSchema>;",
      "packages_schemas_src_report_ts": "import { z } from \"zod\";\nimport { FindingsSchema } from \"./findings\";\nimport { RefactorPlanSchema } from \"./plan\";\n\nexport const ReportSchema = z.object({\n  repoId: z.string(),\n  runId: z.string(),\n  createdAt: z.string(),\n  findings: FindingsSchema,\n  plan: RefactorPlanSchema,\n  riskSummary: z.object({\n    low: z.number().int().min(0),\n    medium: z.number().int().min(0),\n    high: z.number().int().min(0),\n    blocked: z.number().int().min(0),\n  }),\n  notes: z.array(z.string()).default([]),\n});\nexport type Report = z.infer<typeof ReportSchema>;",
      "packages_schemas_src_telemetry_ts": "import { z } from \"zod\";\n\nexport const TelemetryEventSchema = z.object({\n  at: z.string(),\n  name: z.string(),\n  level: z.enum([\"debug\", \"info\", \"warn\", \"error\"]).default(\"info\"),\n  data: z.record(z.unknown()).optional(),\n});\n\nexport const TelemetrySchema = z.object({\n  runId: z.string(),\n  repoId: z.string(),\n  events: z.array(TelemetryEventSchema),\n  counters: z.record(z.number()).default({}),\n});\nexport type Telemetry = z.infer<typeof TelemetrySchema>;",
      "packages_schemas_src_index_ts": "export * from \"./evidence\";\nexport * from \"./findings\";\nexport * from \"./plan\";\nexport * from \"./report\";\nexport * from \"./telemetry\";"
    },
    "5_tool_vitest_config": {
      "title": "إعداد Vitest داخل أداة repo-refactor-ai نفسها (اختياري لكنه متسق)",
      "vitest_config_ts": "import { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    environment: \"node\",\n    include: [\"packages/**/src/**/*.test.ts\"],\n    exclude: [\"**/node_modules/**\", \"**/dist/**\", \"artifacts/**\"],\n  },\n});"
    },
    "6_electron_basic_configs": {
      "title": "إعدادات Electron الأساسية (Configs فقط)",
      "apps_desktop_electron_builder_yml": "appId: com.local.reporefctorai\nproductName: Repo Refactor AI\ndirectories:\n  output: dist-app\nfiles:\n  - \"dist/**\"\n  - \"package.json\"\nasar: true\nwin:\n  target:\n    - nsis\nmac:\n  target:\n    - dmg\nlinux:\n  target:\n    - AppImage",
      "apps_desktop_tsconfig_json": {
        "extends": "../../tsconfig.node.json",
        "compilerOptions": {
          "rootDir": "src",
          "outDir": "dist",
          "composite": true,
          "declaration": false
        },
        "include": [
          "src/main/**/*.ts",
          "src/preload/**/*.ts"
        ]
      },
      "apps_desktop_src_renderer_vite_config_ts": "import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\nexport default defineConfig({\n  plugins: [react()],\n  root: __dirname,\n  base: \"./\",\n  build: {\n    outDir: \"../../../dist/renderer\",\n    emptyOutDir: true\n  }\n});",
      "apps_desktop_src_renderer_tsconfig_json": {
        "extends": "../../../tsconfig.base.json",
        "compilerOptions": {
          "jsx": "react-jsx",
          "types": [
            "vite/client"
          ],
          "noEmit": true
        },
        "include": [
          "src/**/*.ts",
          "src/**/*.tsx"
        ]
      }
    },
    "7_operational_note": {
      "title": "ملاحظة تشغيلية لازمة لربط “harness داخل repo الهدف”",
      "description": "هذه ليست ملف إعداد، لكنها قاعدة تنفيذ تُطبَّق في packages/planning وpackages/refactor:",
      "rules": [
        "خطوة add_harness تكتب .refactor-harness/* في repo الهدف.",
        "خطوة generate_baseline تنشئ ملفات baseline داخل: .refactor-harness/fixtures/baseline/*.json",
        "خطوة verify تشغل: vitest -c .refactor-harness/vitest.config.ts"
      ]
    }
  }
}